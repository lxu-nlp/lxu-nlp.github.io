---
layout: post
title: "Theory of Computing (3): Context-Free Grammar, Chomsky Normal Form and Pushdown Automaton"
date: 2019-03-02
categories: [Theory of Computing]
tags: [cfg]
math: true
---

This article is part of my review notes of "Theory of Computation" course. It introduces the **Context-Free Grammar** which can express more than regular language; also introduces its equivalence **Pushdown Automaton**. **Chomsky Normal Form** is also introduced when dealing with ambiguous parsing.

## Context-Free Grammar

![cfg](/assets/img/legacy/cfg.png)

Variables can be substituted by other variables and terminals, while terminals cannot be present at the left side of the rules. The language $L(G)$ generated by some context-free grammar $G$ is called a **context-free language**.

The sequence of substitution is called **derivation**, and this chain of substitution can be represented by parse tree.

CFG example:

![cfg](/assets/img/legacy/cfg2.png)

##### Ambiguity

Ambiguity is a problem during parsing/derivation. From the book: sometimes a grammar can generate the same string in several different ways; such a string will have several different parse trees and thus several different meanings. If a grammar generates the same string in several different ways, we say that the grammar is ambiguous.

For example:

![cfg](/assets/img/legacy/cfg3.png)

## Chomsky Normal Form

Chomsky Normal Form(CNF) puts some constraints on the grammar rules while preserving the same language. The benefit is that if a grammar is in CNF, then we can avoid the ambiguity problem during parsing.

![cfg](/assets/img/legacy/cfg4.png)

Another benefit of CNF is that it provides an upper bound for parsing complexity. For any string $w$ with length $n$, the derivation must be $2n-1$ steps: $n-1$ steps to obtain length $n$, and another $n$ steps to replace variables with terminals. The worst case is just to enumerate all possible derivations with $2n-1$ steps, which is exponential; but at least it is solvable. There also exists "CYK" algorithm that can solve CNF in $O(n^3)$.

We want to find a way to convert any context-free grammar (CFG) into CNF. The conversion is straightforward and I will skip the details on the book. Here is the example:

![cfg](/assets/img/legacy/cfg5.png)

## Pushdown Automaton

Pushdown automaton (PDA) is similar to NFA but with an additional memory component called stack. PDA can write symbols on the stack and read them back later. Writing a symbol “pushes down” all the other symbols on the stack. At any time the symbol on the top of the stack can be read and removed.

![cfg](/assets/img/legacy/cfg6.png)

PDA Example: (each edge represents (input symbol, popping symbol -> pushing symbol))

![cfg](/assets/img/legacy/cfg7.png)

##### Equivalence with CFG

PDA is equivalent to context-free grammar (CFG). The equivalence is useful because it gives us two options for proving that a language is context free.

CFG $\to$ PDA:

![cfg](/assets/img/legacy/cfg8.png)

This direction is intuitive. One thing to notice is that if the parsing is ambiguous (more than one way to parse), the conversion uses the nondeterminism property to get the PDA (as shown in rule a).

Notice that the stack simulates the leftmost derivation of CFG.

PDA $\to$ CFG:

![cfg](/assets/img/legacy/cfg9.png)

## Context-Free Language

Intuitively, since PDA has more components than DFA (because of the additional stack), we would imagine that any context-free language generated by PDA or CFG is more expressive than regular language.

Theorem: any regular language is context-free.

It is easy to prove since any DFA can be represented by PDA.

![cfg](/assets/img/legacy/cfg10.png)

Last thing, context-free language is closed under union, concatenation, star, but not closed under intersection or complementation.
